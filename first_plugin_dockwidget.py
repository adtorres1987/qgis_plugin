# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MyPluginDockWidget
                                 A QGIS plugin
 My first plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-11-04
        git sha              : $Format:%H$
        copyright            : (C) 2025 by David Torres
        email                : davidt1987@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt.QtWidgets import QDockWidget, QMessageBox, QTableWidgetItem
from qgis.PyQt.QtCore import pyqtSignal, Qt
from qgis.utils import iface

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'first_plugin_dockwidget_base.ui'))


class MyPluginDockWidget(QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(MyPluginDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # will store the displayed features (parallel list to the table)
        self._features = []

        # connect buttons and signals
        try:
            self.btnLoadAttributes.clicked.connect(self.load_attributes)
        except Exception:
            pass

        try:
            # filter on text change (applied to already loaded features)
            self.lineEdit.returnPressed.connect(self.apply_filter)
        except Exception:
            pass

        try:
            # double click on cell -> zoom to geometry of the row
            self.tableWidget.itemDoubleClicked.connect(self.on_item_double_clicked)
        except Exception:
            pass

        # initial table configuration
        try:
            self.tableWidget.setColumnCount(0)
            self.tableWidget.setRowCount(0)
            # select full row on click
            self.tableWidget.setSelectionBehavior(self.tableWidget.SelectRows)
            self.tableWidget.setEditTriggers(self.tableWidget.NoEditTriggers)
        except Exception:
            pass

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def load_attributes(self):
        """Load attributes of the active layer into tableWidget and save features."""
        layer = iface.activeLayer()
        if layer is None:
            QMessageBox.warning(self, "MyPlugin", "No active layer. Select or load a layer.")
            self._set_info("No active layer.")
            return

        # check if vectorial
        try:
            if layer.type() != layer.VectorLayer:
                QMessageBox.warning(self, "MyPlugin", "The active layer is not a vector layer.")
                self._set_info("The active layer is not a vector layer.")
                return
        except Exception:
            pass

        # fields and count
        fields = [f.name() for f in layer.fields()]
        total = layer.featureCount()

        # limit rows to avoid hanging QGIS
        MAX_ROWS = 1000
        features = []
        for i, feat in enumerate(layer.getFeatures()):
            features.append(feat)
            if i + 1 >= MAX_ROWS:
                break

        # save full features (before filtering)
        self._features_all = features  # list with QgsFeature objects
        # by default the view shows all except if there is text in lineEdit
        filter_text = ""
        try:
            filter_text = self.lineEdit.text().strip()
        except Exception:
            filter_text = ""

        if filter_text:
            # apply simple filter (substring in any field)
            self._features = [f for f in features if self._feature_matches(f, filter_text)]
        else:
            self._features = features

        # prepare table
        tbl = self.tableWidget
        tbl.clear()
        tbl.setColumnCount(len(fields))
        tbl.setRowCount(len(self._features))
        if fields:
            tbl.setHorizontalHeaderLabels(fields)

        # fill the table
        for i, feat in enumerate(self._features):
            for j, fname in enumerate(fields):
                val = feat[fname]
                text = "" if val is None else str(val)
                item = QTableWidgetItem(text)
                # optional: align numbers to the right
                if isinstance(val, (int, float)):
                    item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
                tbl.setItem(i, j, item)

        info_text = f"Showing {len(self._features)} of {total} records."
        if total > MAX_ROWS:
            info_text += f" (limit read: {MAX_ROWS})"
        if filter_text:
            info_text += f" â€” filter: '{filter_text}'"
        self._set_info(info_text)

    def apply_filter(self):
        """Reapply filter on already loaded features (uses lineEdit)."""
        try:
            filter_text = self.lineEdit.text().strip()
        except Exception:
            filter_text = ""

        if not hasattr(self, "_features_all"):
            # if no features are loaded yet, call load_attributes
            self.load_attributes()
            return

        if filter_text:
            self._features = [f for f in self._features_all if self._feature_matches(f, filter_text)]
        else:
            self._features = list(self._features_all)

        # update table maintaining the same fields (rebuild)
        if not self._features:
            # clear table
            try:
                self.tableWidget.clear()
                self.tableWidget.setRowCount(0)
                self._set_info("There are no records that match the filter.")
            except Exception:
                pass
            return

        fields = [fld.name() for fld in self._features_all[0].fields()] if self._features_all else []
        tbl = self.tableWidget
        tbl.clear()
        tbl.setColumnCount(len(fields))
        tbl.setRowCount(len(self._features))
        if fields:
            tbl.setHorizontalHeaderLabels(fields)

        for i, feat in enumerate(self._features):
            for j, fname in enumerate(fields):
                val = feat[fname]
                text = "" if val is None else str(val)
                item = QTableWidgetItem(text)
                tbl.setItem(i, j, item)

        self._set_info(f"Showing {len(self._features)} records (filter applied).")

    def _feature_matches(self, feat, text):
        """Returns True if any column in the feature contains the substring text (case-insensitive)."""
        low = text.lower()
        for f in feat.fields():
            try:
                v = feat[f.name()]
                if v is None:
                    continue
                if low in str(v).lower():
                    return True
            except Exception:
                continue
        return False

    def on_item_double_clicked(self, item):
        """At double click on a cell, center the map on the geometry of the corresponding row."""
        row = item.row()
        try:
            feat = self._features[row]
        except Exception:
            QMessageBox.information(self, "MyPlugin", "The entity associated with the row was not found.")
            return

        geom = feat.geometry()
        if geom is None or geom.isEmpty():
            QMessageBox.information(self, "MyPlugin", "The entity has no geometry.")
            return

        # get bbox and center the canvas
        bbox = geom.boundingBox()
        canvas = iface.mapCanvas()
        canvas.setExtent(bbox)
        canvas.refresh()

    def _set_info(self, text):
        """Writes to lblInfo if it exists; if not, shows QMessageBox."""
        try:
            self.lblInfo.setText(text)
        except Exception:
            QMessageBox.information(self, "MyPlugin", text)
